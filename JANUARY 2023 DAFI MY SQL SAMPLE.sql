-- MARYAM KAREEM 
-- FOR QUANTUM ANALYTICS NG 


-- DATA DEFINITION LANGUAGE 
-- USED TO DEFINE DATABASE OBJCTS 


-- CREATE
-- USED TO CREATE A NEW DB OBJECT 

-- CREATE A DATABASE 
CREATE DATABASE QA_DAFI;


-- CREATE A TABLE 
-- TO CREATE A TABLE 
-- STEPS TO FOLLOW 

-- USE THE KEYWORD ==> CREATE TABLE TABLE_NAME()
-- WITHIN THE BRACKET, YOU ADD YOUR COLUMNS 
-- YOU SPECIFY THE DATATYPES FOR THE COLUMNS 
	-- DATATYPES: NUMERICAL ==> INT, FLOAT
			-- CHARACTER BASED ==> VARCHAR(10), CHAR(10)
			-- DATES: DATE, DATETIME, TIME
-- YOU SPECIFY THE CONSTRAINTS ON EACH COLUMNS 
	-- ARE RULES GUIDING A COLUMN 
	-- UNIQUE: EACH OF THE ROWS ARE UNIQUE	
	-- NOT NULL: THE COLUMN MUST NOT ACCEPT NULL VALUES
	-- PRIMARY KEY: UNIQUE + NOTNULL

	CREATE TABLE JAN_DAFI_2023(
	STUDENTID INT PRIMARY KEY,
	NAME VARCHAR(20) NOT NULL,
	GENDER CHAR(1) NOT NULL,
	LOCATION VARCHAR(20) NOT NULL
	);

SELECT * FROM JAN_DAFI_2023;
SELECT * FROM JAN_2023;

-- ALTER
-- USED TO DO SOME MODIFICATIONS TO TABLES 

-- ADD COLUMNS TO TABLES
ALTER TABLE JAN_DAFI_2023
ADD SCORES FLOAT NOT NULL;

SELECT * FROM JAN_DAFI_2023;
-- MODIFY THE DATAYPE OF A COLUMN IN A TABLE 

ALTER TABLE JAN_DAFI_2023
ALTER COLUMN SCORES INT NOT NULL;

-- DELETE A COLUMN FROM A TABLES 

ALTER TABLE JAN_DAFI_2023
DROP COLUMN SCORES;


SELECT * FROM JAN_DAFI_2023;

-- DROP 
-- USED TO DELETE DATABASE OBJECTS ENTIRELY 

-- DROP A DATABASE 
-- DROP DATABASE DB_NAME

-- DROP A TABLE 
-- DROP TABLE TABLE_NAME 

---------------------------------------------------

-- DATA MANIPULATION LANGUAGE 
-- USED TO MANIPULATE THE DATA IN THE DATABASE 

-- SELECT
-- USED TO FETCH COLUMNS FROM A TABLE IN A DATABASE 
-- FECH ALL COLUMNS USING THE * AFTER THE SELECT STATEMENT 

SELECT * FROM JAN_DAFI_2023;

-- FETCH SOECIFIC COLUMNS  BY ADDD THE NAMES OF THE CLUMNS AFTER THE SELECT STATEMENT 

SELECT STUDENTID, NAME, GENDER FROM JAN_DAFI_2023;

-- INSERT
-- USED TO INSERT DATA INTO THE TABLE IN A DATABASE 

-- STEPS TO FOLLOW 
-- USE THE KEYWORD ==? INSERT INTO TABLENAME()
-- WITHIN THE BRACKET, YOU ADD THE COLUMNS THAT WE WANT INSERT INTO 
-- AD DTHE KEYWORD VALUES() TO INITIALISE ADDING VALUES 
-- IN THE BRACKET, YOU ADD THE CORRESPONNDING VALUES FOR THE COLUMNS 

INSERT INTO JAN_DAFI_2023
	(STUDENTID, NAME, GENDER, LOCATION)
VALUES 
	(001, 'REGINALD', 'M', 'SWEDEN'),
	(002, 'LUTHER', 'F', 'ABUJA');

SELECT * FROM JAN_DAFI_2023;

select * from jan_2023;

-- UPDATE 
-- USED TO MAKE CHANGES IN DATA 
UPDATE JAN_DAFI_2023
SET LOCATION = 'WUSE'
WHERE STUDENTID = 002;

-- DELETE 
-- USED TO DELETE RECORDS FROM A TABLE 

DELETE FROM JAN_DAFI_2023
WHERE STUDENTID = 003;

-------------------------------------------

-- SORTING RECORDS 
-- WE USE ORDER BY TO SORT RECORDS 

-- ASCENDING ==> ASC 
-- DESCENDING ==> DESC 

SELECT * FROM JAN_DAFI_2023
ORDER BY NAME ASC;

SELECT * FROM Person.Person;
SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FIRSTNAME ASC;

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FIRSTNAME ASC, LastName ASC;

-- LIMITING RECORDS 
-- TOP N ==> USED TO LIMIT RECORDS IN MSSQL 
-- USUALLY WITHIN THE SELECT STATMENT 
-- N ==> NUMBER OF RECORDS WE WANT TO RETURN 

SELECT TOP 10 FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FIRSTNAME ASC, LASTNAME ASC;

-- AGGREGATE FUNCTIONS 
-- USED TO AGGREGATE DATA 

-- SUM: SUMS UP ALL THE VALUES IN A COLUMN 
-- COUNT: COUNT ALL THE VALUES IN A COLUMN
-- MIN: MINIMUM VALUE
-- MAX: MAXIMUM VALUE
-- VAR: VARIANCE OF VALLUES 
-- STDEV: STANDARD DEVIATION OF VALUES 

SELECT SUM(LINETOTAL) AS TOTAL_AMT, COUNT(*) AS COUNT_OF_AMOUT, 
MIN(LINETOTAL) AS MIN_AMT, MAX(LINETOTAL) AS MAX_AMT, 
VAR(LINETOTAL) AS VARIANCE, STDEV(LINETOTAL) AS STD_DEVIATION 
FROM SALES.SalesOrderDetail;

-- ALIASES
-- AS  ==> USED TO RENAME 
SELECT FIRSTNAME, LASTNAME AS SURNAME FROM Person.Person;


-- FILTERING RECORDS 
-- WHERE --> KEYWORD FOR FILTERING RECORDS 
-- OPERATORS 
	-- MATHEMATICAL OPERATORS: >, <, =, !=, >=, <= 
	-- LOGICAL OPERATORS: AND, OR 

-- GET INFO OF ALL BLACK PRODUCT 
SELECT * FROM Production.Product
WHERE COLOR = 'BLACK';


-- GET INFO OF ALL BLACK PRODUCT  THAT ARE GREATER THAN 1000
SELECT * FROM Production.Product
WHERE COLOR = 'BLACK' AND LISTPRICE > 1000;

SELECT * FROM Production.Product
WHERE COLOR = 'BLACK' AND LISTPRICE > 1000
ORDER BY LISTPRICE ASC;

-- PREDICATE 

-- BETWEEN: FILTER WITHIN RANGES OF VALUES 

-- GET INFO OF PRODCUT BETWEEN 1000 AND 1500

SELECT * FROM Production.Product
WHERE LISTPRICE BETWEEN 1000 AND 1500;

-- GET INFO OF BLACK PRODCUT BETWEEN 1000 AND 1500
SELECT * FROM Production.Product
WHERE COLOR = 'BLACK' AND LISTPRICE BETWEEN 1000 AND 1500;


-- IN : FILTER MULTPLE RECORDS IN A SINGLE COLUMN 

-- WE WANT INFORMATION ON OUR BLUE,SILVER AND RED PRODUCT 

SELECT * FROM Production.Product
WHERE COLOR IN ('RED', 'BLUE', 'SILVER')
ORDER BY COLOR ASC; 

-- LIKE 
-- USED FOR PATTERN FILTERING 
-- % --< USED TO FILTER AS MANY CHARACTERS AS POSSIBLE 
-- _ --< USED TO FILTER ONE CHARACER AT A TIME 

-- WE WANT FULLNAME OF SOMEONE WHOSE FIRSTNAME STARTS WITH JAC 

SELECT FIRSTNAME, LASTNAME FROM PERSON.Person
WHERE FIRSTNAME LIKE 'JAC%';


--WE NEED THE FULL NAME OF SOMEONE WHOSE FIRSTNAME ENDS WITH YN

SELECT FIRSTNAME, LASTNAME FROM Person.Person
WHERE FIRSTNAME LIKE '%YN';

--WE NEED THE FULL NAME OF SOMEONE WHOSE FIRSTNAME STARTS WITH JAC ENDS WITH YN

SELECT FIRSTNAME, LASTNAME FROM Person.Person
WHERE FIRSTNAME LIKE 'JAC%YN';

--------------------------------------------------------------

-- GROUP BY 
-- USED TO GROUP ROWS 
-- USED TO GROUP ROWS WITH THE SAME VALUES INTO SUMMARY ROWS
-- USED WITH AGGREGATE FUNCTIONS 

-- HOW MANY COLORS DO WE HAVE PER PRODUCT 
SELECT * FROM Production.Product;

SELECT COUNT(NAME) AS NO_OF_PRODUCT, COLOR FROM Production.Product
GROUP BY COLOR;

SELECT COLOR, COUNT(NAME) AS NO_OF_PRODUCT  FROM Production.Product
GROUP BY COLOR;

-- TOTAL AMOUNT MADE FROM EACH PRODUCT 
SELECT * FROM Sales.SalesOrderDetail;



SELECT PRODUCTID, SUM(LINETOTAL) AS TOTAL_AMOUNT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
ORDER BY PRODUCTID ASC;

-- HAVING 
-- USED TO FILTER RECORDS THAT HAVE BEEN GROUPED 
-- ALLOWS US TO APPLY FILTERING CONDITIONS TO AGGREGATED DATA AFTER GROUPING HAS OCCURED
-- IT WORKS JUST LIKE WHERE 
-- WORKS WITH OPERATORS: >,<, AND, OR ETC 
-- WORKS WITH PREDICATE: LIKE, BETWEEN,OR 

-- WE WANT PRODUCTS THAT MADE BETWEEN 150K AND 200K 
SELECT PRODUCTID, SUM(LINETOTAL) AS TOTAL_AMOUNT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
HAVING SUM(LINETOTAL) BETWEEN 150000 AND 200000;


-- JOINS 
-- USED TO MERGE TABLES TOGETHER 

-- HOW TO JOIN 
-- IDENTIFY THE TABLES WE ARE JOINING 
-- TAKE NOTE OF THE RELATIONSHIP BETWEEN THE TABLES 
-- TAKE NOTE OF THE COLUMNS  NEEDED TO SOLVE THE QUESTION/QUERRY 
-- MERGE ALL THE COLUNMS TOGERTHER IN A SINGLE SELECT STATEMENT 
-- ADD THE FIRST TABLE AFTER THE FROM STATEMENT
-- ADD OUR JOIN TYPE 
-- ADD OUR SECOND TABLE 
-- INTORDUCE THE JOINING CONDITION ==> USING THE 'ON' KEYWORD 
-- PREVENT AMBIGOUS COLUMNS
	-- RENAME OUR TABLES 
	-- WE USE THE TABLE.COLUMNAME SYNTAX FOR THE COLUMNS THAT ARE AMBIGOUS 

-- INNER JOIN
-- WE WANT TO KNOW THE NAMES OF OUR EMPLOYEES 

SELECT * FROM Person.Person;
-- BUSINESSENTITYID, FIRSTNAME, LASTNAME 
SELECT * FROM HumanResources.Employee
-- BUSINESSENTITYID, JOBTITLE

-- RELATIONSHIP ==> BUSINESSENTITYID 
SELECT BUSINESSENTITYID, FIRSTNAME, LASTNAME, BUSINESSENTITYID, JOBTITLE
FROM Person.Person
INNER JOIN HumanResources.Employee
ON BusinessEntityID =BusinessEntityID;

-- TRYING TO REMOVE THE AMBIGOUS COLUMNS 
SELECT P.BUSINESSENTITYID, FIRSTNAME, LASTNAME, E.BUSINESSENTITYID, JOBTITLE
FROM Person.Person AS P
INNER JOIN HumanResources.Employee AS E
ON P.BusinessEntityID = E.BusinessEntityID;

-- LEFT OUTER JOIN
-- GET ALL THE CUSTOMERS AND CONFIRM WHETHER THEY HAVE ORDERED OR NOT 
SELECT * FROM Sales.Customer;
-- CUSTOMERID
SELECT * FROM SALES.SalesOrderHeader;
-- SALESORDERID, ORDERDATE, CUSTOMERID, TOTALDUE

-- RELATIONSHIP: CUSTOMERID

SELECT C.CUSTOMERID, SALESORDERID, ORDERDATE, S.CUSTOMERID, TOTALDUE
FROM SALES.Customer AS C
LEFT OUTER JOIN Sales.SalesOrderHeader AS S
ON C.CustomerID = S.CustomerID;



-- SET OPERATORS 
-- UNION & UNION ALL
-- USED TO MERGE TWO SELECT STATEMENT TOGETHER

--UNION ==> MERGE WITHOUT DUPLICATES 
-- UNION ALL ==> MERGE WITH DUPLICATE INCLUDED 
 
 -- RULES 
 -- THE NO ON COLUMNS IN THE SELECT STATEMENT MUST BE THE SAME 
 -- THE DATATYPE OF THE CORRESTPONDING SELECT STATEMENT MUST ALSO BE THE SAME

 SELECT * FROM JAN_2023
 UNION ALL
 SELECT * FROM JAN_DAFI_2023;

 SELECT S_NO FROM JAN_2023
 UNION 
 SELECT STUDENTID FROM JAN_DAFI_2023;

SELECT S_NO FROM JAN_2023
UNION ALL
SELECT STUDENTID FROM JAN_DAFI_2023;


-- STRING FUNCTIONS 

-- UPPER : USED TO CHANGE THE STRING OR DATA TO UPPERCASE 
SELECT UPPER(S_NAME) AS S_NAME FROM JAN_2023

-- LOWER : USED TO CHANGE THE STRING TO LOWER CASES 
SELECT LOWER(S_NAME) AS S_NAME FROM JAN_2023;

SELECT LOWER(FIRSTNAME), LOWER(LASTNAME) FROM Person.Person

-- LEFT: USED TO ETRACT CHARACTERS FROM THE LEFT SIDE 
-- LEFT( COLUMN, N)

SELECT LEFT(FIRSTNAME, 2) FROM Person.Person

-- RIGHT: USED TO EXTRACT CHARACTERS FROM THE RIGHT SIDE 

SELECT RIGHT(LASTNAME, 3) FROM Person.Person;

-- CONCAT: USED TO MERGE TWO COLUMNS TOGETHER 
SELECT CONCAT(FIRSTNAME, LASTNAME) FROM Person.Person
SELECT CONCAT(FIRSTNAME, ' ', LASTNAME) FROM Person.Person

-- CONCAT_WS: USED TO MERGE COLUMNS, WITH SEPERATORS 

SELECT CONCAT_WS(' ', FIRSTNAME, LASTNAME) AS FULLNAME FROM Person.Person;

SELECT CONCAT_WS(',', FIRSTNAME, LASTNAME) AS FULLNAME FROM Person.Person

-- CAST: USED TO CONVERT DATATYPE FROM ONE DATATYPE TO ANOTHER 
-- CAST (COLUMN AS DATATYPE)








